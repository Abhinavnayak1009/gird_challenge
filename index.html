<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Grid Challenge - Ball Sequence Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #2c3e50; color: white; height: 100vh; display: flex; flex-direction: column;
    }

    /* Header styling to match original exactly */
    .header {
      background: #34495e; padding: 15px 20px; display: flex; align-items: center;
      justify-content: space-between; border-bottom: 2px solid #2c3e50;
    }
    .header-left { display: flex; align-items: center; gap: 15px; }
    .control-btn {
      width: 50px; height: 50px; background: #95a5a6; border: none; border-radius: 8px;
      cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px;
    }
    .control-btn:hover { background: #bdc3c7; }
    .level-indicator { background: #34495e; padding: 10px 20px; border-radius: 25px; font-size: 18px; font-weight: bold; color: white; }

    .progress-container { flex: 1; max-width: 600px; margin: 0 20px; position: relative; }
    .progress-bar { background: white; height: 40px; border-radius: 20px; position: relative; overflow: hidden; }
    .progress-fill { background: #e67e22; height: 100%; border-radius: 20px; width: 0%; transition: width 0.3s ease; }
    .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; font-weight: bold; color: #8B0000; }

    .header-right { display: flex; align-items: center; gap: 20px; }
    .timer { background: #95a5a6; padding: 10px 20px; border-radius: 25px; font-size: 18px; font-weight: bold; color: #2c3e50; }
    .game-title { font-size: 24px; font-weight: bold; }

    /* Main content area */
    .main-content { flex: 1; position: relative; background: #ecf0f1; }

    /* Symmetry overlay with clear separation */
    .symmetry-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #ecf0f1;
      display: none; flex-direction: column; z-index: 1000;
    }
    .symmetry-header { background: #95a5a6; padding: 15px; text-align: right; font-size: 28px; font-weight: bold; color: #2c3e50; }
    .symmetry-content { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; }
    .symmetry-question { font-size: 24px; color: #7f8c8d; margin-bottom: 40px; text-align: center; }

    .grid-container { background: #bdc3c7; padding: 50px; border-radius: 15px; margin-bottom: 40px; box-shadow: 0 8px 16px rgba(0,0,0,0.1); position: relative; }
    .symmetry-grid {
      display: grid; grid-template-columns: repeat(5, 35px) 80px repeat(5, 35px);
      grid-template-rows: repeat(5, 35px); gap: 8px; margin-bottom: 20px; justify-content: center; position: relative;
    }
    .symmetry-grid::before {
      content: ''; position: absolute; left: 50%; top: -10px; bottom: -10px; width: 3px; background: #e74c3c;
      transform: translateX(-50%); z-index: 10; border-radius: 2px; box-shadow: 0 0 8px rgba(231, 76, 60, 0.5);
    }
    .symmetry-grid::after {
      content: 'SYMMETRY AXIS'; position: absolute; left: 50%; top: -40px; transform: translateX(-50%);
      font-size: 12px; font-weight: bold; color: #e74c3c; background: rgba(231, 76, 60, 0.1); padding: 4px 8px; border-radius: 4px;
    }
    .grid-cell { width: 35px; height: 35px; background: #34495e; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: all 0.2s ease; }

    /* Hide the middle column (symmetry axis) */
    .grid-cell:nth-child(6),
    .grid-cell:nth-child(17),
    .grid-cell:nth-child(28),
    .grid-cell:nth-child(39),
    .grid-cell:nth-child(50) { visibility: hidden; }

    .grid-cell:hover { transform: scale(1.05); }
    .grid-cell.dot { background: #34495e; border-radius: 50%; width: 12px; height: 12px; margin: 11.5px auto; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

    .symmetry-buttons { display: flex; gap: 40px; }
    .symmetry-btn { width: 200px; height: 80px; border: none; border-radius: 15px; font-size: 32px; font-weight: bold; color: white; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    .symmetry-btn.yes { background: #16537e; }
    .symmetry-btn.no  { background: #16537e; }
    .symmetry-btn:hover { opacity: 0.8; transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }

    /* Game board */
    .game-board { width: 100%; height: 100%; background: #bdc3c7; position: relative; overflow: hidden; }
    .game-instruction {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(52, 73, 94, 0.9); padding: 15px 30px; border-radius: 25px; font-size: 24px; font-weight: bold; color: white; z-index: 100;
    }

    /* UNIFORM BALL STYLING */
    .ball {
      position: absolute; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; transition: all 0.3s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 14px; background: #95a5a6; color: #2c3e50;
    }
    .ball.active { background: #f39c12 !important; transform: scale(1.3); box-shadow: 0 6px 15px rgba(243, 156, 18, 0.6); color: white !important; animation: ballPulse 0.8s ease-in-out; }
    @keyframes ballPulse { 0%, 100% { transform: scale(1.3); } 50% { transform: scale(1.5); } }
    .ball.correct { background: #27ae60 !important; color: white !important; }
    .ball.correct::after { content: "✓"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; font-weight: bold; }
    .ball.wrong { background: #e74c3c !important; color: white !important; }
    .ball.wrong::after { content: "✕"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; font-weight: bold; }

    .ball.selected { background: #3498db !important; color: white !important; transform: scale(1.1); border: 3px solid #2980b9; }
    .ball.selected::after {
      content: attr(data-sequence-number); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: white; font-size: 20px; font-weight: bold;
    }

    /* Start screen */
    .start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #bdc3c7;
      display: flex; align-items: center; justify-content: center; z-index: 500;
    }
    .start-content {
      text-align: center; background: rgba(44, 62, 80, 0.95); padding: 40px 50px; border-radius: 20px;
      backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 500px;
    }
    .start-title { font-size: 36px; font-weight: bold; margin-bottom: 20px; color: #f1c40f; }
    .start-instruction { font-size: 18px; margin-bottom: 30px; opacity: 0.9; color: white; }
    .timing-controls { display: flex; justify-content: center; gap: 40px; margin-bottom: 30px; }
    .timing-input { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .timing-label { font-size: 16px; font-weight: bold; color: #ecf0f1; }
    .timing-slider { width: 150px; height: 6px; background: rgba(255, 255, 255, 0.3); border-radius: 3px; outline: none; cursor: pointer; }
    .start-btn {
      padding: 15px 40px; font-size: 24px; font-weight: bold; background: #27ae60; color: white; border: none; border-radius: 15px;
      cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .start-btn:hover { background: #2ecc71; transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.3); }

    /* Selection UI */
    .selection-progress {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(52, 73, 94, 0.9);
      padding: 12px 25px; border-radius: 15px; display: none; z-index: 200;
    }
    .progress-info { font-size: 16px; font-weight: bold; text-align: center; color: white; }

    .submit-button {
      position: absolute; bottom: 20px; right: 20px; padding: 12px 25px; font-size: 16px; font-weight: bold;
      background: #27ae60; color: white; border: none; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; display: none; z-index: 200;
    }
    .submit-button:hover { background: #2ecc71; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }

    .reset-button {
      position: absolute; bottom: 20px; left: 20px; padding: 12px 25px; font-size: 16px; font-weight: bold;
      background: #e74c3c; color: white; border: none; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; display: none; z-index: 200;
    }
    .reset-button:hover { background: #c0392b; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }

    /* Symmetry timer bubble */
    .symmetry-timer {
      position: absolute; top: 15px; right: 15px; background: #e74c3c; color: white; padding: 8px 16px; border-radius: 20px;
      font-size: 20px; font-weight: bold; min-width: 50px; text-align: center; z-index: 1100;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <div class="header-left">
      <button class="control-btn" id="playBtn">▶</button>
      <button class="control-btn" id="soundBtn">🔊</button>
      <div class="level-indicator">Level <span id="levelNum">1</span></div>
    </div>

    <div class="progress-container">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
        <div class="progress-text" id="progressText">1</div>
      </div>
    </div>

    <div class="header-right">
      <div class="timer" id="timer">05:00</div>
      <div class="game-title">Grid Challenge</div>
    </div>
  </div>

  <!-- Main -->
  <div class="main-content">
    <!-- Start screen -->
    <div class="start-screen" id="startScreen">
      <div class="start-content">
        <h2 class="start-title">Grid Challenge</h2>
        <p class="start-instruction">Set your preferences and start the challenge:</p>

        <div class="timing-controls">
          <div class="timing-input">
            <label class="timing-label">Ball Time: <span id="ballTimeLabel">2.0s</span></label>
            <input type="range" class="timing-slider" id="ballTimeSlider" min="1" max="5" step="0.1" value="2">
          </div>
          <div class="timing-input">
            <label class="timing-label">Symmetry: <span id="symmetryTimeLabel">3.0s</span></label>
            <input type="range" class="timing-slider" id="symmetryTimeSlider" min="1" max="8" step="0.1" value="3">
          </div>
        </div>

        <button class="start-btn" id="startBtn">Start Game</button>
      </div>
    </div>

    <!-- Symmetry overlay -->
    <div class="symmetry-overlay" id="symmetryOverlay">
      <div class="symmetry-timer" id="symmetryTimer">5</div>
      <div class="symmetry-header">Is it Symmetric..?</div>
      <div class="symmetry-content">
        <div class="symmetry-question" id="symmetryQuestion">Mirror symmetry across red line?</div>
        <div class="grid-container">
          <div class="symmetry-grid" id="symmetryGrid"><!-- cells by JS --></div>
        </div>
        <div class="symmetry-buttons">
          <button class="symmetry-btn yes" id="symYesBtn">yes</button>
          <button class="symmetry-btn no"  id="symNoBtn">no</button>
        </div>
      </div>
    </div>

    <!-- Selection UI -->
    <div class="selection-progress" id="selectionProgress">
      <div class="progress-info">Selected: <span id="selectedCount">0</span> / <span id="totalNeeded">3</span></div>
    </div>
    <button class="reset-button"  id="resetButton">Reset</button>
    <button class="submit-button" id="submitButton">Submit</button>

    <!-- Board -->
    <div class="game-board" id="gameBoard">
      <div class="game-instruction" id="gameInstruction">Press Start to Begin!</div>
    </div>
  </div>

  <script>
  (function () {
    // ---------- Cached DOM ----------
    const els = {
      playBtn: document.getElementById('playBtn'),
      startBtn: document.getElementById('startBtn'),
      startScreen: document.getElementById('startScreen'),
      gameBoard: document.getElementById('gameBoard'),
      gameInstruction: document.getElementById('gameInstruction'),
      levelNum: document.getElementById('levelNum'),
      timer: document.getElementById('timer'),
      progressFill: document.getElementById('progressFill'),
      progressText: document.getElementById('progressText'),
      selectionProgress: document.getElementById('selectionProgress'),
      selectedCount: document.getElementById('selectedCount'),
      totalNeeded: document.getElementById('totalNeeded'),
      resetButton: document.getElementById('resetButton'),
      submitButton: document.getElementById('submitButton'),
      ballTimeSlider: document.getElementById('ballTimeSlider'),
      symTimeSlider: document.getElementById('symmetryTimeSlider'),
      ballTimeLabel: document.getElementById('ballTimeLabel'),
      symTimeLabel: document.getElementById('symmetryTimeLabel'),
      symmetryOverlay: document.getElementById('symmetryOverlay'),
      symmetryTimer: document.getElementById('symmetryTimer'),
      symmetryGrid: document.getElementById('symmetryGrid'),
      symmetryQuestion: document.getElementById('symmetryQuestion'),
      symYesBtn: document.getElementById('symYesBtn'),
      symNoBtn: document.getElementById('symNoBtn'),
    };

    // ---------- Game State ----------
    let gameActive = false;
    let gamePaused = false;
    let level = 1;

    let timeLeft = 300;           // seconds
    let gameTimer = null;

    let sequenceStep = 0;
    const totalSteps = 6;         // 3 balls + 3 symmetry
    let currentProgress = 1;
    const maxProgress = 6;

    const levelAdvancementThreshold = 70;
    const maxLevel = 10;

    // Sequences
    let ballSequence = [];        // all balls placed on board
    let shownSequence = [];       // sequence of indices shown (active)
    let symmetryResults = [];     // {correct:boolean}
    let selectedBallsInOrder = []; // user picks
    let inSelectionPhase = false;

    // Timings
    let ballDisplayTime = 2000;   // ms
    let symmetryTime = 3000;      // ms
    let symmetryTimer = null;
    let symmetryTimeLeft = 0;
    let currentSymmetryPattern = null;

    // Patterns (same as your list)
    const symmetryPatterns = [
      {
        pattern: [1,1,1,1,1,0,1,1,1,1,1,
                  1,0,0,0,0,0,1,0,1,0,1,
                  1,0,1,0,0,0,1,0,1,0,1,
                  1,0,0,0,0,0,1,0,1,1,1,
                  1,1,1,1,1,0,1,1,0,0,1],
        symmetric: false, question: "Mirror symmetry across red line?"
      },
      {
        pattern: [1,1,1,1,1,0,1,1,1,1,1,
                  1,0,0,0,0,0,0,0,0,0,1,
                  1,1,1,1,1,0,1,1,1,1,1,
                  0,0,0,0,1,0,1,0,0,0,0,
                  1,1,1,1,1,0,1,1,1,1,1],
        symmetric: true, question: "Mirror symmetry across red line?"
      },
      {
        pattern: [1,0,1,0,1,0,1,0,1,0,1,
                  0,1,0,1,0,0,0,1,0,1,0,
                  1,0,1,0,1,0,1,0,1,0,1,
                  0,1,0,1,0,0,0,1,0,1,0,
                  1,0,1,0,1,0,1,0,1,0,1],
        symmetric: true, question: "Mirror symmetry across red line?"
      },
      {
        pattern: [1,1,0,0,1,0,1,0,0,1,1,
                  0,1,1,0,0,0,0,0,1,1,0,
                  1,0,1,1,0,0,0,1,1,0,1,
                  0,0,1,0,1,0,1,0,1,0,0,
                  1,1,0,0,1,0,1,0,0,1,1],
        symmetric: false, question: "Mirror symmetry across red line?"
      },
      {
        pattern: [1,1,1,0,0,0,0,0,1,1,1,
                  1,0,0,1,0,0,0,1,0,0,1,
                  1,0,0,0,1,0,1,0,0,0,1,
                  1,0,0,1,0,0,0,1,0,0,1,
                  1,1,1,0,0,0,0,0,1,1,1],
        symmetric: true, question: "Perfect mirror symmetry?"
      },
      {
        pattern: [0,1,1,1,0,0,0,1,1,1,1,
                  1,0,0,0,1,0,1,0,0,0,1,
                  1,1,0,1,1,0,1,1,0,1,1,
                  1,0,0,0,1,0,1,0,0,0,1,
                  0,1,1,1,0,0,0,1,1,1,0],
        symmetric: false, question: "Mirror symmetry across red line?"
      },
      {
        pattern: [1,0,0,0,1,0,1,0,0,0,1,
                  0,1,1,1,0,0,0,1,1,1,0,
                  0,1,0,1,0,0,0,1,0,1,0,
                  0,1,1,1,0,0,0,1,1,1,0,
                  1,0,0,0,1,0,1,0,0,0,1],
        symmetric: true, question: "Is this symmetric?"
      }
    ];

    // ---------- Utilities ----------
    const clearInt = (id) => { if (id) { clearInterval(id); } return null; };

    function updateTimer() {
      if (!gameActive || gamePaused) return;
      if (timeLeft <= 0) return endGame("Time's Up!");
      const m = Math.floor(timeLeft / 60);
      const s = timeLeft % 60;
      els.timer.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      timeLeft -= 1;
    }

    function updateProgress() {
      const pct = (currentProgress / maxProgress) * 100;
      els.progressFill.style.width = pct + '%';
      els.progressText.textContent = currentProgress;
    }

    function updateLevelUI() {
      els.levelNum.textContent = level;
    }

    function setInstruction(text) { els.gameInstruction.textContent = text; }

    // ---------- Board / Balls ----------
    function createBalls() {
      // Remove any existing balls
      els.gameBoard.querySelectorAll('.ball').forEach(b => b.remove());

      // Cap to prevent DOM explosion
      const ballCount = Math.min(15 + level * 4, 50);
      const positions = [];
      const rect = els.gameBoard.getBoundingClientRect();

      ballSequence = [];

      for (let i = 0; i < ballCount; i++) {
        let x, y, attempts = 0;
        do {
          x = Math.random() * (rect.width - 80) + 10;
          y = Math.random() * (rect.height - 140) + 60;
          attempts++;
        } while (isOverlapping(x, y, positions, 60, 20) && attempts < 60);

        if (attempts >= 60) continue; // skip if can't place safely

        positions.push({ x, y });

        const ball = document.createElement('div');
        ball.className = 'ball';
        ball.dataset.index = String(i);
        ball.style.left = x + 'px';
        ball.style.top = y + 'px';

        // One handler, selection-phase-gated
        ball.addEventListener('click', () => handleBallClick(i));

        els.gameBoard.appendChild(ball);
        ballSequence.push({ index: i, x, y });
      }
    }

    function isOverlapping(x, y, positions, size = 60, padding = 20) {
      for (const p of positions) {
        const dx = p.x - x, dy = p.y - y;
        if (Math.hypot(dx, dy) < size + padding) return true;
      }
      return false;
    }

    // ---------- Sequence Flow ----------
    function startGame() {
      // Clean state
      cleanupAll();
      level = 1;
      timeLeft = 300;
      sequenceStep = 0;
      currentProgress = 1;
      shownSequence = [];
      symmetryResults = [];
      selectedBallsInOrder = [];
      inSelectionPhase = false;

      updateLevelUI();
      updateProgress();
      setInstruction('Get Ready...');

      // UI
      els.startScreen.style.display = 'none';
      els.playBtn.textContent = '⏸';
      gameActive = true;
      gamePaused  = false;

      // Build board + start timers
      createBalls();
      gameTimer = setInterval(updateTimer, 1000);

      // Begin sequence
      setTimeout(startSequence, 500);
    }

    function startSequence() {
      if (!gameActive) return;
      if (sequenceStep >= totalSteps) return showSelectionPhase();

      // even steps => show ball; odd => symmetry
      if (sequenceStep % 2 === 0) showBall();
      else showSymmetry();
    }

    function showBall() {
      if (!ballSequence.length) {
        // If somehow no balls, create and continue
        createBalls();
        if (!ballSequence.length) return endGame("No balls available to display.");
      }

      const ballIndex = ballSequence[Math.floor(Math.random() * ballSequence.length)].index;
      const ball = els.gameBoard.querySelector(`.ball[data-index="${ballIndex}"]`);
      if (!ball) {
        // safeguard: skip step
        sequenceStep++;
        currentProgress++;
        updateProgress();
        return setTimeout(startSequence, 200);
      }

      setInstruction(`Remember this ball! (${(ballDisplayTime/1000).toFixed(1)}s) - Sequence #${shownSequence.length + 1}`);
      ball.classList.add('active');

      shownSequence.push({
        ballIndex,
        sequenceOrder: shownSequence.length + 1,
        timing: ballDisplayTime,
        step: sequenceStep
      });

      setTimeout(() => {
        ball.classList.remove('active');
        sequenceStep++;
        currentProgress++;
        updateProgress();
        setTimeout(startSequence, 250);
      }, ballDisplayTime);
    }

    function showSymmetry() {
      const pattern = symmetryPatterns[Math.floor(Math.random() * symmetryPatterns.length)];
      currentSymmetryPattern = pattern;

      // Build grid
      els.symmetryQuestion.textContent = pattern.question || 'Mirror symmetry across red line?';
      els.symmetryGrid.innerHTML = '';
      const frag = document.createDocumentFragment();
      pattern.pattern.forEach(cell => {
        const div = document.createElement('div');
        div.className = cell === 1 ? 'grid-cell' : 'grid-cell dot';
        frag.appendChild(div);
      });
      els.symmetryGrid.appendChild(frag);

      // Show overlay & timer
      els.symmetryOverlay.style.display = 'flex';
      startSymmetryTimer();
    }

    function startSymmetryTimer() {
      symmetryTimeLeft = Math.max(1, Math.ceil(symmetryTime / 1000));
      els.symmetryTimer.textContent = String(symmetryTimeLeft);

      symmetryTimer = clearInt(symmetryTimer);
      symmetryTimer = setInterval(() => {
        symmetryTimeLeft--;
        els.symmetryTimer.textContent = String(Math.max(0, symmetryTimeLeft));
        if (symmetryTimeLeft <= 0) {
          symmetryTimer = clearInt(symmetryTimer);
          answerSymmetry(false); // time-out => count as "no"
        }
      }, 1000);
    }

    function answerSymmetry(userAnswer) {
      symmetryTimer = clearInt(symmetryTimer);

      const isCorrect = currentSymmetryPattern
        ? userAnswer === !!currentSymmetryPattern.symmetric
        : false;

      symmetryResults.push({
        correct: isCorrect,
        userAnswer: !!userAnswer,
        step: sequenceStep
      });

      // Hide overlay after a short delay
      setTimeout(() => {
        els.symmetryOverlay.style.display = 'none';
        sequenceStep++;
        currentProgress++;
        updateProgress();
        setTimeout(startSequence, 250);
      }, 200);
    }

    // ---------- Selection Phase ----------
    function showSelectionPhase() {
      inSelectionPhase = true;
      selectedBallsInOrder = [];

      els.selectionProgress.style.display = 'block';
      els.resetButton.style.display = 'block';
      els.submitButton.style.display = 'block';

      els.totalNeeded.textContent = String(shownSequence.length);
      els.selectedCount.textContent = '0';
      setInstruction('Click the balls in the SAME order!');
    }

    function handleBallClick(ballIndex) {
      if (!inSelectionPhase || !gameActive || gamePaused) return;

      const ball = els.gameBoard.querySelector(`.ball[data-index="${ballIndex}"]`);
      if (!ball) return;

      // toggle selection if clicked again
      if (ball.classList.contains('selected')) {
        ball.classList.remove('selected');
        ball.removeAttribute('data-sequence-number');
        // remove from array and re-number
        selectedBallsInOrder = selectedBallsInOrder.filter(v => v !== ballIndex);
        renumberSelected();
      } else {
        selectedBallsInOrder.push(ballIndex);
        ball.classList.add('selected');
        ball.setAttribute('data-sequence-number', String(selectedBallsInOrder.length));
      }

      els.selectedCount.textContent = String(selectedBallsInOrder.length);
    }

    function renumberSelected() {
      // Clear numbers
      els.gameBoard.querySelectorAll('.ball.selected').forEach(b => b.removeAttribute('data-sequence-number'));
      // Re-assign numbers by order in selectedBallsInOrder
      selectedBallsInOrder.forEach((idx, i) => {
        const b = els.gameBoard.querySelector(`.ball[data-index="${idx}"]`);
        if (b) b.setAttribute('data-sequence-number', String(i + 1));
      });
    }

    function resetSelection() {
      selectedBallsInOrder = [];
      els.gameBoard.querySelectorAll('.ball.selected').forEach(b => {
        b.classList.remove('selected');
        b.removeAttribute('data-sequence-number');
      });
      els.selectedCount.textContent = '0';
    }

    function submitFinalAnswer() {
      if (!shownSequence.length) {
        alert('No sequence was shown. Restarting level.');
        return retryCurrentLevel();
      }

      const correctSequence = shownSequence.map(s => s.ballIndex);
      const userSequence = selectedBallsInOrder.slice(0, correctSequence.length);

      let correctSelections = 0;
      for (let i = 0; i < userSequence.length; i++) {
        if (userSequence[i] === correctSequence[i]) correctSelections++;
      }

      const totalNeeded = correctSequence.length;
      const ballScore = Math.round((correctSelections / totalNeeded) * 100);

      const symCorrect = symmetryResults.filter(r => r.correct).length;
      const symTotal = Math.max(1, symmetryResults.length); // avoid /0
      const symmetryScore = Math.round((symCorrect / symTotal) * 100);

      const overallScore = Math.round((ballScore + symmetryScore) / 2);

      if (overallScore >= levelAdvancementThreshold) {
        if (level < maxLevel) {
          const from = level;
          level++;
          alert(
            `Excellent! Level ${from} Complete!\n\n` +
            `Sequence Memory: ${ballScore}% (${correctSelections}/${totalNeeded})\n` +
            `Symmetry: ${symmetryScore}% (${symCorrect}/${symTotal})\n\n` +
            `Overall: ${overallScore}%\n\n🎉 ADVANCING TO LEVEL ${level}! 🎉`
          );
          startNextLevel();
        } else {
          alert(
            `🏆 GAME COMPLETED! 🏆\n\nYou've mastered all ${maxLevel} levels!\n\n` +
            `Final Level Performance:\nSequence Memory: ${ballScore}% (${correctSelections}/${totalNeeded})\n` +
            `Symmetry: ${symmetryScore}% (${symCorrect}/${symTotal})\n\n` +
            `Overall: ${overallScore}%\n\nCongratulations, Memory Master!`
          );
          restartGame();
        }
      } else {
        alert(
          `Level ${level} - Try Again!\n\n` +
          `Sequence Memory: ${ballScore}% (${correctSelections}/${totalNeeded})\n` +
          `Symmetry: ${symmetryScore}% (${symCorrect}/${symTotal})\n\n` +
          `Overall: ${overallScore}%\n\nNeed ${levelAdvancementThreshold}% or higher to advance!\n\n` +
          `🔄 Retrying Level ${level}`
        );
        retryCurrentLevel();
      }
    }

    // ---------- Level Transitions ----------
    function startNextLevel() {
      // Clean without losing level
      basicCleanupForTransition();
      level = Math.min(level, maxLevel);
      timeLeft = 300;

      updateLevelUI();
      updateProgress();
      setInstruction(`Level ${level} - Get Ready!`);

      setTimeout(() => {
        gameActive = true;
        gamePaused = false;
        els.playBtn.textContent = '⏸';

        createBalls();
        gameTimer = setInterval(updateTimer, 1000);
        startSequence();
      }, 600);
    }

    function retryCurrentLevel() {
      basicCleanupForTransition();
      timeLeft = 300;

      updateProgress();
      setInstruction(`Level ${level} - Try Again!`);

      setTimeout(() => {
        gameActive = true;
        gamePaused = false;
        els.playBtn.textContent = '⏸';

        createBalls();
        gameTimer = setInterval(updateTimer, 1000);
        startSequence();
      }, 600);
    }

    function restartGame() {
      cleanupAll();
      // Reset to menu
      level = 1;
      timeLeft = 300;
      sequenceStep = 0;
      currentProgress = 1;
      updateLevelUI();
      updateProgress();
      els.playBtn.textContent = '▶';
      setInstruction('Press Start to Begin!');
      els.startScreen.style.display = 'flex';
    }

    // ---------- Cleanup helpers ----------
    function basicCleanupForTransition() {
      // stop gameplay but keep UI
      gameActive = false;
      gamePaused = false;
      gameTimer = clearInt(gameTimer);
      symmetryTimer = clearInt(symmetryTimer);
      inSelectionPhase = false;

      els.selectionProgress.style.display = 'none';
      els.resetButton.style.display = 'none';
      els.submitButton.style.display = 'none';
      els.symmetryOverlay.style.display = 'none';

      // sequences
      sequenceStep = 0;
      currentProgress = 1;
      shownSequence = [];
      symmetryResults = [];
      selectedBallsInOrder = [];

      // remove balls
      els.gameBoard.querySelectorAll('.ball').forEach(b => b.remove());

      updateTimer(); // refresh UI
    }

    function cleanupAll() {
      basicCleanupForTransition();
      // also ensure menu visible state if called from endGame
    }

    function endGame(msg) {
      alert(msg);
      restartGame();
    }

    // ---------- Controls / UI ----------
    function togglePause() {
      if (!gameActive) return;
      gamePaused = !gamePaused;
      els.playBtn.textContent = gamePaused ? '▶' : '⏸';
      setInstruction(gamePaused ? 'Game Paused' : 'Back to it!');
    }

    function setupTimingSliders() {
      // Remove previous listeners by cloning (prevents stacking)
      const ballSlider = els.ballTimeSlider.cloneNode(true);
      const symSlider  = els.symTimeSlider.cloneNode(true);

      els.ballTimeSlider.parentNode.replaceChild(ballSlider, els.ballTimeSlider);
      els.symTimeSlider.parentNode.replaceChild(symSlider, els.symTimeSlider);

      // Update cached refs
      els.ballTimeSlider = ballSlider;
      els.symTimeSlider = symSlider;

      // Initialize labels
      els.ballTimeLabel.textContent = (ballDisplayTime/1000).toFixed(1) + 's';
      els.symTimeLabel.textContent = (symmetryTime/1000).toFixed(1) + 's';

      ballSlider.addEventListener('input', (e) => {
        const v = Math.max(1, Math.min(5, parseFloat(e.target.value) || 2));
        ballDisplayTime = Math.round(v * 100) / 100 * 1000;
        els.ballTimeLabel.textContent = (ballDisplayTime/1000).toFixed(1) + 's';
      }, { passive: true });

      symSlider.addEventListener('input', (e) => {
        const v = Math.max(1, Math.min(8, parseFloat(e.target.value) || 3));
        symmetryTime = Math.round(v * 100) / 100 * 1000;
        els.symTimeLabel.textContent = (symmetryTime/1000).toFixed(1) + 's';
      }, { passive: true });
    }

    // ---------- One-time bindings ----------
    function bindStaticHandlersOnce() {
      // Start
      els.startBtn.addEventListener('click', () => {
        // debounce clicks
        if (gameActive) return;
        startGame();
      });

      // Pause/Resume
      els.playBtn.addEventListener('click', togglePause);

      // Selection controls
      els.resetButton.addEventListener('click', resetSelection);
      els.submitButton.addEventListener('click', submitFinalAnswer);

      // Symmetry buttons
      els.symYesBtn.addEventListener('click', () => answerSymmetry(true));
      els.symNoBtn.addEventListener('click',  () => answerSymmetry(false));

      // Keyboard shortcuts (overlay only)
      document.addEventListener('keydown', (e) => {
        if (!gameActive || gamePaused) return;
        if (els.symmetryOverlay.style.display !== 'flex') return;

        const key = e.key.toLowerCase();
        if (key === 'y' || key === '1') answerSymmetry(true);
        if (key === 'n' || key === '2') answerSymmetry(false);
      });

      // Handle resize so balls stay inside bounds on first paint (optional – no heavy relayout)
      window.addEventListener('resize', () => {
        // no expensive recompute; keep it simple & safe
      }, { passive: true });
    }

    // ---------- Init ----------
    function init() {
      updateLevelUI();
      updateProgress();
      // initial timer text
      els.timer.textContent = '05:00';
      setInstruction('Press Start to Begin!');
      setupTimingSliders();
      bindStaticHandlersOnce();
    }

    // kick off
    window.addEventListener('load', init);
  })();
  </script>
</body>
</html>
